# 5. Development with ROS

## Assignments

These assignments require you to understand many different aspects of
the development workflow to perform. Feel free to (i) reach out for
help when you are working on them and (ii) contribute to the
documentation site afterward.

### 1: ROS Environment

Create a Docker development environment and then create a catkin
workspace. Develop a ROS package that has both Python and C++ nodes
and build it.

Commands used: 
    docker pull ros
    docker run -it ros
    
    mkdir -p ~/catkin_ws/src
    catkin_init_workspace
    cd ~/catkin_ws/
    source devel/setup.bash
    catkin_make
    cd ~/catkin_ws/src
    catkin_create_pkg task1_package std_msgs rospy roscpp
    catkin_make
    source devel/setup.bash
    
    #created a file.cpp in tasks1_package/src folder
    #made relevant changes in the CMakeLists.txt (uploaded) [added an executable (add_executable) named task1__pakage_node with the source file named           src/file.cpp.       
    Also within the CMakeLists.txt, make sure that task1_package executable gets linked (target_link_libraries) to the catkin libraries.] 
    
    #created a file2.py in tasks1_package/src folder
    #created a "setup.py" file to link to the file2.py file (uploaded) 
    Also within the CMakeLists.txt, make sure thatcd task1_package executable gets linked (target_link_libraries) to the catkin libraries.] 
    
    roscore (Terminal 1)
    rosrun task1_package file2.py (Terminal 2)
    rosnode list (Terminal 3)

### 2: Python library

In the ROS package, develop a library that has this simple function:

```python
def add(x, y):
    return x + y
```

    catkin_create_pkg task2_package std_msgs rospy roscpp
    catkin_make
    source devel/setup.bash
    
    #created a python file named add.py with the basic add function in task1_package/src.
    
    mkdir add
    vim __init__.py
    vim function_caller.py
    
    cd catkin_ws
    catkin_make
    source devel/setup.bash
    
    rosrun task2_package function_caller
    

Show that you can create **another** package that produces a Python
node that uses this function.

### 3: A simple ROS Node

Extend the above two packages to build a node that satisfies the
following requirements:

- read from the ROS parameter server a parameter called `gain`;
    roscore
    rosparam set gain 7
    
- provide a service that accepts two numbers, and return the value
  calculated by this equation `gain * (x + y)`;
  
  #!/usr/bin/env python3

from get_function.srv import addtwoints
from get_function.srv import addtwointsRequest
from get_function.srv import addtwointsResponse

import rospy


def handle_add_two_ints(req):
    print("Returning %s(%s + %s) = %s" % (req.gain, req.a, req.b, req.gain*(req.a + req.b)))
    response = addtwointsResponse(req.gain*(req.a + req.b))
    return response

def add_two_ints_server():
    rospy.init_node('add_two_ints_server')
    s = rospy.Service('add_two_ints', addtwoints, handle_add_two_ints)
    print("Ready to run function.")
    rospy.spin()


if __name__ == "__main__":
    add_two_ints_server()
    
    
- provides a service, that when the user calls, toggles the node to
  publish a ROS topic. The thread should be running at 100hz.

    
#!/usr/bin/env python3

from get_function.srv import addtwoints
from get_function.srv import addtwointsRequest
from get_function.srv import addtwointsResponse

import rospy 
import sys

def add_two_ints_client(x, y):
    rospy.wait_for_service('add_two_ints')
    try: #service proxy sends information to the server
        sp = rospy.ServiceProxy('add_two_ints', addtwoints) 
        resp1 = sp(z, x, y)
        return resp1.func
    except rospy.ServiceException as e:
        print("Service call failed: %s" % e)
         
if __name__ == "__main__":
    z = rospy.get_param('gain')
    if len(sys.argv) == 3:
        x = int(sys.argv[1])
        y = int(sys.argv[2])
    else:
        print("%s [z x y]" % sys.argv[0])
        sys.exit(1)
    print("Requesting %s(%s + %s)" % (z, x, y))
    s = add_two_ints_client(x, y)
    print("%s(%s + %s) = %s" % (z, x, y, s))
    
    
### 4: Deployment

Develop a build system using `pyinvoke` that build the two ROS
packages and copy the build artifacts into another Docker image. This
image should be named `super-ros-node`.

When this docker image is ran using the below command, the node
developed in Part 3 should be running.

```sh
docker run super-ros-node
```
